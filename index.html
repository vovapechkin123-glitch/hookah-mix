<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>THE MENU</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<style>
:root { color-scheme: dark; }

body{
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
  background: radial-gradient(1200px 800px at 30% 20%, #2b2b38 0%, #0b0b12 55%, #05050a 100%);
  color:#fff;
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:24px;
}

.card{
  width:min(600px,100%);
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  border-radius:18px;
  padding:22px;
  backdrop-filter: blur(10px);
  box-shadow:0 20px 60px rgba(0,0,0,.45);
}

.screen{display:none}
.screen.active{display:block}

h1{margin:0 0 12px;font-size:24px}
h2{margin:14px 0 8px;font-size:14px;letter-spacing:.6px;text-transform:uppercase;opacity:.7}

p{opacity:.85;line-height:1.5;margin:0 0 10px}

.btn{
  width:100%;
  margin-top:14px;
  padding:14px;
  border-radius:14px;
  border:0;
  font-size:16px;
  font-weight:700;
  cursor:pointer;
  background:rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.14);
  color:#fff;
}
.btn:disabled{opacity:.5;cursor:not-allowed}

.btn.primary{
  background:rgba(237,230,214,.12);
  border:1px solid rgba(237,230,214,.22);
}

.btnRow{
  display:flex;
  gap:10px;
  margin-top:12px;
}
.btnRow .btn{margin-top:0;width:100%}

.option{
  padding:14px;
  border-radius:14px;
  background:rgba(255,255,255,.08);
  margin-top:10px;
  cursor:pointer;
  border:1px solid rgba(255,255,255,.10);
}
.option:hover{background:rgba(255,255,255,.14)}
.option.selected{
  background:rgba(237,230,214,.12);
  border:1px solid rgba(237,230,214,.28);
}

.small{font-size:13px;opacity:.7}
.muted{opacity:.72}

.timer{
  font-size:30px;
  text-align:center;
  letter-spacing:2px;
  margin:14px 0
}

.order{
  background:rgba(255,255,255,.08);
  border-radius:14px;
  padding:14px;
  margin-top:12px;
  border:1px solid rgba(255,255,255,.10);
}

.fadeIn{
  animation:fadeIn .18s ease-out;
}
@keyframes fadeIn{
  from{opacity:0; transform:translateY(6px)}
  to{opacity:1; transform:translateY(0)}
}

.badge{
  font-size:12px;
  padding:6px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.12);
  display:inline-block;
}
.badge.warn{background:rgba(255,140,0,.15)}
.badge.done{background:rgba(255,255,255,.15)}

.listLine{
  display:flex;
  justify-content:space-between;
  gap:10px;
  align-items:flex-start;
  padding:8px 0;
  border-top:1px solid rgba(255,255,255,.10);
}
.listLine:first-child{border-top:0}
</style>
</head>

<body>
<div class="card">

<!-- ===== ЛИЧНЫЙ КАБИНЕТ (СТАРТ) ===== -->
<div class="screen" id="dashboard">
  <h1 id="dashTitle">Добро пожаловать.</h1>
  <p>
    <b>Это не заказ.</b><br>
    <b>Это момент.</b>
  </p>
  <p class="small muted">25 минут. Один раз. Без повторов.</p>

  <button class="btn primary" id="dashMainBtn" onclick="dashboardMainAction()">…</button>
  <button class="btn" id="dashHistoryBtn" onclick="showHistory()">Открыть историю</button>

  <h2>Процедура</h2>
  <div class="listLine">
    <div class="small">7 вопросов</div>
    <div class="small muted">без объяснений</div>
  </div>
  <div class="listLine">
    <div class="small">1 решение</div>
    <div class="small muted">без выбора вкуса</div>
  </div>
  <div class="listLine">
    <div class="small">1 исполнение</div>
    <div class="small muted">без повторов</div>
  </div>

  <h2>Правила</h2>
  <div class="listLine">
    <div class="small">Дверь открывается только внутри</div>
    <div class="small muted">гео-допуск</div>
  </div>
  <div class="listLine">
    <div class="small">После подтверждения — назад нельзя</div>
    <div class="small muted">строго</div>
  </div>
  <div class="listLine">
    <div class="small">Уникальность не обсуждается</div>
    <div class="small muted">всегда</div>
  </div>

  <p class="small muted" style="text-align:center;margin-top:16px">
    Вы не выбираете вкус.<br>
    Вы выбираете условия.
  </p>
</div>

<!-- ===== ПРОЛОГ ===== -->
<div class="screen" id="s0">
  <h1>Прежде чем мы начнём.</h1>
  <p>
    Здесь не выбирают вкус.<br><br>
    Здесь фиксируют момент.<br><br>
    То, что вы получите,<br>
    не существует заранее.
  </p>

  <button class="btn primary" onclick="go('door')">Продолжить</button>
  <button class="btn" onclick="go('dashboard')">Назад</button>
</div>

<!-- ===== ДВЕРЬ (ГЕО) ===== -->
<div class="screen" id="door">
  <h1>Дверь открывается только внутри.</h1>
  <p id="doorText">
    Мы не готовим это снаружи.<br><br>
    Разрешите местоположение.<br>
    Один раз.
  </p>

  <button class="btn primary" id="btnDoor" onclick="doorCheck()">Открыть дверь</button>
  <button class="btn" id="btnBot" onclick="openBot()">Передать координаты через Telegram</button>

  <button class="btn" onclick="go('s0')">Назад</button>
</div>

<!-- ===== СНАРУЖИ / НЕТ СИГНАЛА ===== -->
<div class="screen" id="outside">
  <h1>Снаружи это не готовят.</h1>
  <p id="outsideText">Вы слишком далеко.</p>
  <div class="btnRow">
    <button class="btn primary" onclick="doorCheck()">Проверить снова</button>
    <button class="btn" onclick="go('dashboard')">Вернуться</button>
  </div>
</div>

<!-- ===== БЕЗ ДОПУСКА ===== -->
<div class="screen" id="no-permission">
  <h1>Без допуска нельзя.</h1>
  <p>
    Это не просьба.<br>
    Это правило.
  </p>
  <div class="btnRow">
    <button class="btn primary" onclick="doorCheck()">Попробовать снова</button>
    <button class="btn" onclick="go('dashboard')">Вернуться</button>
  </div>
</div>

<!-- ===== ОШИБКА ГЕО ===== -->
<div class="screen" id="geo-error">
  <h1>Устройство молчит.</h1>
  <p>
    Оно не отдаёт местоположение.<br>
    Значит, сегодня — без этого.
  </p>
  <div class="btnRow">
    <button class="btn primary" onclick="doorCheck()">Попробовать снова</button>
    <button class="btn" onclick="openBot()">Передать координаты через Telegram</button>
  </div>
  <button class="btn" onclick="go('dashboard')">Вернуться</button>
</div>

<!-- ===== КУРС (7 ВОПРОСОВ) ===== -->
<div class="screen" id="course">
  <h1 id="qTitle">…</h1>
  <p id="qText">…</p>
  <div id="qOptions"></div>
  <div id="qFooter" style="margin-top:12px"></div>
</div>

<!-- ===== ПОДТВЕРЖДЕНИЕ ===== -->
<div class="screen" id="confirm">
  <h1>Я услышал.</h1>
  <p>
    Вы выбрали условия.<br>
    Остальное — моя работа.
  </p>
  <button class="btn primary" id="btnConfirm" onclick="confirmMoment()">Подтвердить</button>
  <button class="btn" onclick="backToLastQuestion()">Вернуться</button>
  <p class="small" id="confirmHint" style="margin-top:10px"></p>
</div>

<!-- ===== ОЖИДАНИЕ ===== -->
<div class="screen" id="waiting">
  <h1>Процесс начался.</h1>
  <p>Не торопите момент.</p>
  <div class="timer" id="guestTimer">25:00</div>
  <p class="small" id="guestHint"></p>
</div>

<!-- ===== ЭПИЛОГ ===== -->
<div class="screen" id="epilogue">
  <h1>Это было сделано</h1>
  <p>
    именно для этого момента.<br><br>
    Дальше — без интерфейса.
  </p>
  <button class="btn primary" onclick="showHistory()">Вернуться</button>
</div>

<!-- ===== ИСТОРИЯ ===== -->
<div class="screen" id="history">
  <h1>Ваши моменты</h1>
  <div id="historyList"></div>
  <button class="btn primary" onclick="startNewMoment()">Создать новый момент</button>
  <button class="btn" onclick="go('dashboard')">Назад</button>
</div>

</div>

<script>
/* ===== НАСТРОЙКИ ===== */
const BACKEND_BASE = "https://hookah-mix-bot-56x5.onrender.com";
const DURATION_MS = 25 * 60 * 1000;

const BOT_USERNAME = "@hookah_mixPanda_bot";

/* Геозона (СЕЙЧАС: ДОМ ДЛЯ ТЕСТА) */
const VENUE = {
  lat: 56.519963,
  lng: 84.933527,
  radius: 40
};

/* LocalStorage keys */
const LS_MOMENTS = "tm_moments";
const LS_ACTIVE = "tm_active_moment";

/* Telegram */
const tg = window.Telegram?.WebApp;
tg?.expand?.();

const tgUser = tg?.initDataUnsafe?.user;
const guest = {
  id: tgUser?.id || null,
  name: tgUser?.first_name || "Гость",
  username: tgUser?.username || null
};

let guestTimerInt = null;

/* ===== ВОПРОСЫ ===== */
const QUESTIONS = [
  { id:"q1", title:"Не думайте долго.", text:"Что ближе прямо сейчас?", type:"single", options:["Тепло","Холод","Тень","Свет"] },
  { id:"q2", title:"Близость.", text:"Насколько близко подойти?", type:"single", options:["На расстоянии","Ближе","Почти вплотную","Без шагов назад"] },
  { id:"q3", title:"Источник.", text:"Откуда это должно прийти?", type:"single", options:["Из земли","С веток","Из печи","Из дыма"] },
  { id:"q4", title:"Материал.", text:"Если бы это можно было потрогать — оно было бы…", type:"single", options:["Бархат","Стекло","Дерево","Камень"] },
  { id:"q5", title:"Касание.", text:"Это должно коснуться вас как…", type:"single", options:["Шерсть","Хлопок","Металл","Лёд"] },
  { id:"q6", title:"Сегодня нельзя.", text:"Выберите то, что разрушит момент.", type:"multi", max:3, options:["Детская сладость","Кислая агрессия","Парфюм","Компот","Медицинская свежесть","Тяжёлые специи"] },
  { id:"q7", title:"Контроль.", text:"Сколько контроля вы оставляете себе?", type:"single", options:["Весь","Почти весь","Меньше половины","Ничего"] }
];

let currentQIndex = 0;
let answers = {};

/* ===== UI ===== */
function go(id){
  document.querySelectorAll(".screen").forEach(s=>s.classList.remove("active","fadeIn"));
  const el = document.getElementById(id);
  if(el){
    el.classList.add("active","fadeIn");
  }
}

function haptic(type="light"){
  try{ tg?.HapticFeedback?.impactOccurred?.(type); }catch(e){}
}

/* ===== ХРАНИЛИЩЕ ===== */
function loadMoments(){
  try{ return JSON.parse(localStorage.getItem(LS_MOMENTS)||"[]"); }catch(e){ return []; }
}
function saveMoments(list){ localStorage.setItem(LS_MOMENTS, JSON.stringify(list)); }
function getActiveMoment(){
  try{ return JSON.parse(localStorage.getItem(LS_ACTIVE)||"null"); }catch(e){ return null; }
}
function setActiveMoment(m){ localStorage.setItem(LS_ACTIVE, JSON.stringify(m)); }
function clearActiveMoment(){ localStorage.removeItem(LS_ACTIVE); }

/* ===== ЭПИТЕТЫ ===== */
const EPITHET_ADJ = ["Тёплая","Холодная","Тёмная","Светлая","Тихая","Резкая","Сухая","Мягкая","Плотная","Чистая","Строгая","Нервная","Тяжёлая","Лёгкая"];
const EPITHET_NOUN = ["Пауза","Точность","Тишина","Сцена","Линия","Грань","Комната","Ночь","Ясность","Тень","Привычка","Воля","Траектория","Память"];

function lastEpithets(n=5){
  const list = loadMoments();
  return list.slice(-n).map(m=>m.epithet).filter(Boolean);
}
function generateEpithet(){
  const recent = new Set(lastEpithets(5));
  for(let i=0;i<30;i++){
    const a = EPITHET_ADJ[Math.floor(Math.random()*EPITHET_ADJ.length)];
    const b = EPITHET_NOUN[Math.floor(Math.random()*EPITHET_NOUN.length)];
    const e = `${a} ${b}`;
    if(!recent.has(e)) return e;
  }
  return `${EPITHET_ADJ[0]} ${EPITHET_NOUN[0]}`;
}

/* ===== BOT FALLBACK ===== */
function openBot(){
  tg?.openTelegramLink?.(`https://t.me/${BOT_USERNAME.replace("@","")}?start=geo`);
}

/* ===== GEO ===== */
function getGeolocation(){
  return new Promise((resolve,reject)=>{
    if(!navigator.geolocation){
      reject({ code: "not_supported" });
      return;
    }

    const tryGet = (opts) => new Promise((res, rej) => {
      navigator.geolocation.getCurrentPosition(
        pos => res({
          lat: pos.coords.latitude,
          lng: pos.coords.longitude,
          accuracy: pos.coords.accuracy
        }),
        err => rej(err),
        opts
      );
    });

    tryGet({ enableHighAccuracy:true, timeout:20000, maximumAge:0 })
      .then(resolve)
      .catch(async (err)=>{
        try{
          const pos = await tryGet({ enableHighAccuracy:false, timeout:20000, maximumAge:60000 });
          resolve(pos);
        }catch(err2){
          reject(err2 || err);
        }
      });
  });
}

async function apiGeoCheck(lat,lng){
  const r = await fetch(`${BACKEND_BASE}/geo/check`,{
    method:"POST",
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ lat, lng, venue: VENUE })
  });
  return r.json();
}

async function apiGeoSession(){
  if(!guest.id) return { ok:true, allowed:false };
  const r = await fetch(`${BACKEND_BASE}/geo/session?userId=${guest.id}`);
  return r.json();
}

/* ===== ДВЕРЬ ===== */
async function doorCheck(){
  const btn = document.getElementById("btnDoor");
  const txt = document.getElementById("doorText");
  btn.disabled = true;
  txt.innerHTML = "Секунду.<br>Мы проверяем, где вы.";

  try{
    const geo = await getGeolocation();
    const data = await apiGeoCheck(geo.lat, geo.lng);

    if(data?.ok && data.allowed){
      haptic("medium");
      startCourse();
      return;
    }

    const dist = Math.round(data?.distanceMeters ?? 9999);
    document.getElementById("outsideText").innerHTML =
      `Вы слишком далеко.<br>Сейчас между нами примерно <b>${dist} м</b>.<br><br>Подойдите ближе. И попробуйте снова.`;
    go("outside");
  }catch(e){
    const s = await apiGeoSession();
    if(s?.ok && s.allowed){
      haptic("medium");
      startCourse();
      return;
    }

    if(e?.code === 1){
      go("no-permission");
      return;
    }
    go("geo-error");
  }finally{
    btn.disabled = false;
    txt.innerHTML = `Мы не готовим это снаружи.<br><br>Разрешите местоположение.<br>Один раз.`;
  }
}

/* ===== КУРС ===== */
function startCourse(){
  answers = {};
  currentQIndex = 0;
  renderQuestion();
  go("course");
}

function renderQuestion(){
  const q = QUESTIONS[currentQIndex];
  document.getElementById("qTitle").textContent = q.title;
  document.getElementById("qText").textContent = q.text;

  const box = document.getElementById("qOptions");
  const footer = document.getElementById("qFooter");
  box.innerHTML = "";
  footer.innerHTML = "";

  if(q.type === "single"){
    q.options.forEach(opt=>{
      const div = document.createElement("div");
      div.className = "option";
      div.textContent = opt;
      div.onclick = () => {
        haptic("light");
        answers[q.id] = opt;

        if(q.id === "q2" && opt === "Без шагов назад"){
          setTimeout(nextQuestion, 250);
        }else{
          nextQuestion();
        }
      };
      box.appendChild(div);
    });
  }

  if(q.type === "multi"){
    const selected = new Set(answers[q.id] || []);
    const max = q.max || 3;

    q.options.forEach(opt=>{
      const div = document.createElement("div");
      div.className = "option" + (selected.has(opt) ? " selected" : "");
      div.textContent = opt;

      div.onclick = () => {
        haptic("light");
        if(selected.has(opt)){
          selected.delete(opt);
        }else{
          if(selected.size >= max) return;
          selected.add(opt);
        }
        answers[q.id] = Array.from(selected);
        renderQuestion();
      };

      box.appendChild(div);
    });

    const count = document.createElement("div");
    count.className = "small";
    count.textContent = `Выбрано: ${selected.size}/${max}`;
    footer.appendChild(count);

    const btn = document.createElement("button");
    btn.className = "btn primary";
    btn.textContent = "Дальше";
    btn.onclick = () => {
      haptic("medium");
      nextQuestion();
    };
    footer.appendChild(btn);
  }
}

function nextQuestion(){
  if(currentQIndex < QUESTIONS.length - 1){
    currentQIndex++;
    renderQuestion();
  }else{
    go("confirm");
  }
}

function backToLastQuestion(){
  currentQIndex = QUESTIONS.length - 1;
  renderQuestion();
  go("course");
}

/* ===== ПОДТВЕРЖДЕНИЕ ===== */
async function confirmMoment(){
  const btn = document.getElementById("btnConfirm");
  const hint = document.getElementById("confirmHint");
  btn.disabled = true;
  hint.textContent = "Проверяем допуск…";

  try{
    let allowed = false;

    try{
      const geo = await getGeolocation();
      const data = await apiGeoCheck(geo.lat, geo.lng);
      allowed = !!(data?.ok && data.allowed);
    }catch(e){
      const s = await apiGeoSession();
      allowed = !!(s?.ok && s.allowed);
    }

    if(!allowed){
      hint.textContent = "Нужен допуск.";
      setTimeout(()=>go("geo-error"), 500);
      return;
    }

    const id = Date.now()+"_"+Math.random().toString(36).slice(2,6);
    const epithet = generateEpithet();

    const moment = {
      id,
      guest,
      createdAt: Date.now(),
      startAt: Date.now(),
      endAt: Date.now() + DURATION_MS,
      status: "active",
      epithet,
      answers,
      venue: VENUE
    };

    const list = loadMoments();
    list.push({
      id: moment.id,
      createdAt: moment.createdAt,
      status: "active",
      epithet: moment.epithet
    });
    saveMoments(list);
    setActiveMoment(moment);

    await fetch(`${BACKEND_BASE}/moment`,{
      method:"POST",
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(moment)
    });

    haptic("heavy");
    go("waiting");
    startTimer(moment.startAt);

  }catch(e){
    hint.textContent = "Кухня молчит.";
  }finally{
    btn.disabled = false;
    setTimeout(()=>{ hint.textContent=""; }, 2500);
  }
}

/* ===== ОЖИДАНИЕ ===== */
function startTimer(start){
  clearInterval(guestTimerInt);

  const hint = document.getElementById("guestHint");
  hint.textContent = "";

  guestTimerInt = setInterval(()=>{
    const d = (start + DURATION_MS) - Date.now();

    if(d <= 0){
      document.getElementById("guestTimer").textContent = "Готово";
      finishActiveMoment();
      clearInterval(guestTimerInt);
      setTimeout(()=>go("epilogue"), 500);
      return;
    }

    const m = Math.floor(d/60000);
    const s = Math.floor((d%60000)/1000);
    document.getElementById("guestTimer").textContent = `${m}:${String(s).padStart(2,"0")}`;

    if(d < 3*60*1000) hint.textContent = "Скоро.";
    else if(d < 10*60*1000) hint.textContent = "Вы почти там.";
    else if(d < 20*60*1000) hint.textContent = "Сейчас всё решается.";
    else hint.textContent = "";

  }, 1000);
}

function finishActiveMoment(){
  const active = getActiveMoment();
  if(!active) return;

  const list = loadMoments();
  const idx = list.findIndex(x => x.id === active.id);
  if(idx !== -1){
    list[idx].status = "done";
    saveMoments(list);
  }

  clearActiveMoment();
}

/* ===== ИСТОРИЯ ===== */
function showHistory(){
  const list = loadMoments();
  const box = document.getElementById("historyList");
  box.innerHTML = "";

  if(!list.length){
    box.innerHTML = `<p class="small">Пока здесь пусто.</p>`;
    go("history");
    return;
  }

  const sorted = [...list].sort((a,b)=>b.createdAt-a.createdAt);

  sorted.forEach(m=>{
    const status = m.status === "active"
      ? `<span class="badge warn">В процессе</span>`
      : `<span class="badge done">Завершено</span>`;

    box.innerHTML += `
      <div class="order">
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap">
          <b>${m.epithet || "Момент"}</b>
          ${status}
        </div>
        <div class="small" style="margin-top:6px">${new Date(m.createdAt).toLocaleString()}</div>
      </div>
    `;
  });

  go("history");
}

/* ===== DASHBOARD LOGIC ===== */
function dashboardMainAction(){
  const active = getActiveMoment();
  if(active && Date.now() < active.endAt){
    go("waiting");
    startTimer(active.startAt);
    return;
  }
  go("s0");
}

function renderDashboard(){
  const title = document.getElementById("dashTitle");
  title.textContent = `Добро пожаловать, ${guest.name}.`;

  const mainBtn = document.getElementById("dashMainBtn");
  const active = getActiveMoment();

  if(active && Date.now() < active.endAt){
    mainBtn.textContent = "Вернуться к моменту";
  }else{
    mainBtn.textContent = "Создать момент";
  }

  const moments = loadMoments();
  const histBtn = document.getElementById("dashHistoryBtn");
  histBtn.style.display = moments.length ? "block" : "none";
}

/* ===== START ===== */
document.addEventListener("DOMContentLoaded", ()=>{
  const active = getActiveMoment();
  if(active && Date.now() < active.endAt){
    go("waiting");
    startTimer(active.startAt);
    return;
  }else{
    clearActiveMoment();
  }

  renderDashboard();
  go("dashboard");
});
</script>

</body>
</html>
